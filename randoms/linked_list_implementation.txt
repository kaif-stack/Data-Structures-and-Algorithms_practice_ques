Kaif
#3218

Kaif
 started a call that lasted 5 minutes.
 — 01/05/2022
Kaif
 started a call that lasted an hour.
 — 01/05/2022
KATboi — 01/06/2022
package com.company;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class Main {


    public static void main(String[] args) {
        int ans = bitwiseComplement(5);
        System.out.println(ans);
    }


    public static int bitwiseComplement(int n) {
        String str = Integer.toBinaryString(n);
        int ans = 0;
        for(int i = 0; i < str.length(); i++) {
            if(str.charAt(i) == '0'){
                ans = ans + (int) Math.round((Math.pow(2, str.length() - i-1)));
            }
        }
        return ans;
    }

    }
looked up this, most of them just convert it into binary and then solve it
Kaif
 started a call that lasted 2 hours.
 — 01/06/2022
KATboi — 01/06/2022
hello
champ
Kaif
 started a call that lasted a few seconds.
 — 01/09/2022
Kaif
 started a call that lasted 13 minutes.
 — 05/12/2022
KATboi — 05/12/2022
abe screen share phone pe bhi hota  h kya?
discord pe
Kaif — 05/12/2022
haan
par awaz ni aati
KATboi — 05/15/2022
https://codeforces.com/problemset/problem/1676/D
Codeforces
Problem - 1676D - Codeforces
Image
KATboi
 started a call that lasted 43 minutes.
 — 05/15/2022
KATboi
 started a call that lasted 2 hours.
 — 05/15/2022
KATboi — 05/15/2022
aaja
bhai
KATboi — 05/15/2022
cin>> arr[i][j] >> arr[i][j] >> arr[i][j] >> arr[i][j]
cin >> arr[i][j];
1 2 3 4
cin >> arr[i][j];
cin >> arr[i][j];
cin >> arr[i][j];
cin >> arr[i][j];
1 2 3 4
2 5 6 7
Kaif — 05/15/2022
1 2
3 4
1 2 3 4
Kaif — 05/15/2022
void solve(){
  int n,m;
  cin>>n>>m;
  vector<vector<int>> ma(n,vector<int>(m));
  f(n){
    for(int j=0;j<m;j++){
    //   int d;
    //   cin>>d;
      cin>>ma[i][j];
    }
  }
  int ans=0;
  f(n){
    for(int j=0;j<m;j++){
      int sum=0;
      sum+=ma[i][j];
      int a=i,b=j,c=i,d=j,e=i,f=j,g=i,h=j;
      while(a>=0 && b>=0){
        sum+=ma[a][b];
        a--;b--;
      }
      while(c>=0 && d<m){
        sum+=ma[c][d];
        c--;
        d++;
      }
      while(e<n && f>=0){
        sum+=ma[e][f];
        e++;
        f--;
      }
      while(g<n && h<m){
        sum+=ma[g][h];
        g++;
        h++;
      }
      sum-=4*ma[i][j];
      ans=max(ans,sum);

    }
  }cout<<ans<<endl;
}
Kaif — 05/15/2022
#include<bits/stdc++.h>
#define ll long long int
#define endl "\n"
#define M 1000000007
 
using namespace std;
 
int main()
{
    ll n, q, i, ans = 0;
    cin >> n >> q;
    ll arr[n+1];
    for(i = 1; i <= n; i++){
        cin >> arr[i]; ans+=arr[i];
    }
 
    ll x, y, z;
    map< ll , ll > mm;
 
    ll current = -1;
    while(q--){
        cin >> x;
        if(x == 2){
            cin >> z;
            ans = n*z;
            cout<<ans;
            mm.clear();
            current = z;
        }
        else{
            cin >> y >> z;
            if(current == -1){
                ans-=arr[y]; ans+=z; arr[y] = z;
                cout<<ans;
            }
            else{
                if(mm[y] == 0) {
                    ans-=current;
                    ans+=z;
                    cout<<ans;
                    mm[y] = z;
                }
                else{
                    ans-=mm[y];
                    ans+=z;
                    mm[y] = z;
                    cout<<ans;
                }
            }
        }
 
        cout<<endl;
    }
}
Kaif
 started a call that lasted 5 minutes.
 — Yesterday at 11:40 PM
KATboi — Yesterday at 11:44 PM
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: g++.exe build active file",
            "command": "C:\msys64\mingw64\bin\g++.exe",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "${file}",
                "-o",
                "${fileDirname}\${fileBasenameNoExtension}.exe"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
{
    "files.associations": {
        "iostream": "cpp"
    }
}
KATboi — Today at 12:04 PM
#include <iostream>
using namespace std;
 struct Rectangle
{
   int width, height;

 };
int main(void) {
    struct Rectangle rec;
    rec.width=8;
    rec.height=5;
   cout<<"Area of Rectangle is: "<<(rec.width * rec.height)<<endl;
 return 0;
}
KATboi
 pinned 
a message
 to this channel. See all 
pinned messages
.
 — Today at 12:04 PM
KATboi — Today at 12:05 PM
a pointer is a variable that contains memory addresses of values
Syntax : (type of data you'll be point to)---> int head ; ( is needed before name)
'*'
asterix is needed before the name
KATboi — Today at 1:45 PM
design Linked List
class Node {
public:
int data;
Node *next;

Node() {
    data = -1;
    next = nullptr;
}

Node(int data_) {
    data = data_;
    next = nullptr;
}
};

class MyLinkedList {
public:
Node *head;
Node *tail;
int length;
MyLinkedList() {
this->head = nullptr;
this->tail = nullptr;
length = 0;
}

int get(int index) {
    if (index >= length) return -1;
    Node *temp = head;
    for (int i = 0; i < index; i++) {
        temp = temp->next;
    }
    return temp->data;
}

void addAtHead(int val) {
    Node *newHead = new Node(val);
    if (!head && !tail) {
        this->head = newHead;
        this->tail = newHead;
    }
    else {
        newHead->next = head;
        head = newHead;
    }
    length++;
}

void addAtTail(int val) {
    Node *newTail = new Node(val);
    if (!head && !tail) {
        this->head = newTail;
        this->tail = newTail;
    }
    else {
        this->tail->next = newTail;
        tail = newTail;
    }
    length++;
}

void addAtIndex(int index, int val) {
    if (index > this->length) return;
    if (index == 0) {
        this->addAtHead(val);
        return;
    }
    if (index == length) {
        this->addAtTail(val);
        return;
    }

    Node *newNode = new Node(val);
    Node *temp = head;
    for (int i = 0; i < index - 1; i++) {
        temp = temp->next;
    }
    newNode->next = temp->next;
    temp->next = newNode;
    length++;
}

void deleteAtIndex(int index) {
    if (index >= this->length) return;
    if (index == 0) {
        Node *temp = head;
        head = head->next;
        delete(temp);
    }
    else if (index == length - 1) {
        Node *temp = head;
        while(temp->next != tail) {
            temp = temp->next;
        }
        delete(tail);
        tail = temp;
    }
    else {
        Node *temp = head;
... (11 lines left)
Collapse
message.txt
3 KB
Kaif — Today at 2:35 PM
Karlia kya tune???
KATboi — Today at 7:17 PM
kya?
paji
nhi yeh leetcode se solution h
KATboi
 started a call that lasted a minute.
 — Today at 9:36 PM
KATboi — Today at 9:36 PM
hello
KATboi
 started a call.
 — Today at 9:36 PM
KATboi — Today at 9:41 PM
https://www.youtube.com/watch?v=-gjxg6Pln50
YouTube
Team AlgoDaily
How to Use the Two Pointer Technique
Image
KATboi — Today at 9:53 PM
yeh jo isne two sum ka example diya h
voh sorted array ke liye sirf true h na?
﻿
class Node {
public:
int data;
Node *next;

Node() {
    data = -1;
    next = nullptr;
}

Node(int data_) {
    data = data_;
    next = nullptr;
}
};

class MyLinkedList {
public:
Node *head;
Node *tail;
int length;
MyLinkedList() {
this->head = nullptr;
this->tail = nullptr;
length = 0;
}

int get(int index) {
    if (index >= length) return -1;
    Node *temp = head;
    for (int i = 0; i < index; i++) {
        temp = temp->next;
    }
    return temp->data;
}

void addAtHead(int val) {
    Node *newHead = new Node(val);
    if (!head && !tail) {
        this->head = newHead;
        this->tail = newHead;
    }
    else {
        newHead->next = head;
        head = newHead;
    }
    length++;
}

void addAtTail(int val) {
    Node *newTail = new Node(val);
    if (!head && !tail) {
        this->head = newTail;
        this->tail = newTail;
    }
    else {
        this->tail->next = newTail;
        tail = newTail;
    }
    length++;
}

void addAtIndex(int index, int val) {
    if (index > this->length) return;
    if (index == 0) {
        this->addAtHead(val);
        return;
    }
    if (index == length) {
        this->addAtTail(val);
        return;
    }

    Node *newNode = new Node(val);
    Node *temp = head;
    for (int i = 0; i < index - 1; i++) {
        temp = temp->next;
    }
    newNode->next = temp->next;
    temp->next = newNode;
    length++;
}

void deleteAtIndex(int index) {
    if (index >= this->length) return;
    if (index == 0) {
        Node *temp = head;
        head = head->next;
        delete(temp);
    }
    else if (index == length - 1) {
        Node *temp = head;
        while(temp->next != tail) {
            temp = temp->next;
        }
        delete(tail);
        tail = temp;
    }
    else {
        Node *temp = head;
        Node *prev = nullptr;
        for (int i = 0; i < index; i++) {
            prev = temp;
            temp = temp->next;
        }
        prev->next = temp->next;
        delete(temp);
    }
    this->length--;
}
};